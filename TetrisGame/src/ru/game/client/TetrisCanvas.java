package ru.game.client;

import java.io.IOException;
//import java.net.UnknownHostException;
//import java.util.Collection;
//import java.util.HashMap;
//import java.util.Map;

import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.GC;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Canvas;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.Text;
import org.eclipse.swt.events.DisposeEvent;
import org.eclipse.swt.events.DisposeListener;
import org.eclipse.swt.events.KeyEvent;
import org.eclipse.swt.events.KeyListener;
import org.eclipse.swt.events.PaintEvent;
import org.eclipse.swt.events.PaintListener;

import ru.game.message.Message;
import ru.game.message.Tetramino;
import ru.game.message.Message.Type;
import ru.game.message.Tetramino.Shape;

public class TetrisCanvas extends Canvas implements PaintListener, Runnable, KeyListener, DisposeListener {

	private Tetramino tetramino;
	private Client client;
	private Message message;

	private volatile boolean gameStarted;// идет ли игра
	private volatile boolean errorWindow = false; // сигнал о появлении окна с
													// ошибкой
	public int gameID; // идентификатор игрока (1 - первый, 2 - второй)
	private int speed = 0; // cкорость игры (милисекунды)

	private int level; // уровень (вляет на замедление, т.е. на скорость падения
						// фигур)
	private final int X_SIZE = 24; // размеры поля в блоках
	private final int Y_SIZE = 24;
	private int score;// очки
	private int gridColor;// цвет фона (для сетки)
	private Image backimage;// объект класса изображений
	private GC gc; // для рисования на изображении
	private Block[][] blocks;
	private Text textInfo;// инф-я о текущем уровне и счете

	private Shape buffer; // хранит текущий выбор второго игрока
	private Shape[] figuresChoose = new Shape[3]; // массив
	boolean choose; // сделал ли выбор 2-й игрок (если нет, фигура генерируется
					// рандомно)

	// конструктор
	public TetrisCanvas(Composite parent) {
		super(parent, SWT.CENTER);// вызываем конструктор суперкласса
		gameStarted = false;
		addPaintListener(this); // лисенер для рисования
		setLayout(new GridLayout());

		textInfo = new Text(this, SWT.NONE);
		textInfo.setLayoutData(new GridData(SWT.FILL, SWT.BEGINNING, true, false));// заполнение
																					// по
																					// горизонтали,
																					// сверху
		addKeyListener(this);// лисенер для клавиш
		addDisposeListener(this);// для очищения

		gridColor = SWT.COLOR_GRAY;// по умолчанию сетка есть

		backimage = new Image(getDisplay(), X_SIZE * 22, Y_SIZE * 23);// создаем
																		// объект
																		// класса
																		// изображений
		gc = new GC(backimage); // будем рисовать на нем
	}

	public void errors(String string) {
		Display.getDefault().asyncExec(new Runnable() {
			@Override
			public void run() {
				Shell shell_help = new Shell(getDisplay(), SWT.TITLE | SWT.CLOSE | SWT.MIN);
				shell_help.setText("Tetris x 2: ошибка");
				GridLayout layout = new GridLayout(1, true);

				shell_help.setLayout(layout);
				shell_help.setBounds(300, 50, 345, 70);

				Label label = new Label(shell_help, SWT.NONE);
				label.setText(string);

				GridData data = new GridData(SWT.FILL, SWT.TOP, true, true, 1, 1);
				label.setLayoutData(data);

				shell_help.open();
			}
		});
	}

	// начинаем новую сессию и ждем второго игрока
	public void waitingPlayer() {
		errorWindow = false;
		gameID = 1;

		new Thread(new Runnable() {
			@Override
			public void run() {

				try {
					client = new Client("127.0.0.1", 5876);
				} catch (Exception e) {
					if (errorWindow == false) {
						errors("Произошла непредвиденная ошибка: попробуйте еще раз");
						errorWindow = true;
					}

				}

				try {
					client.createSession();
					Display.getDefault().asyncExec(new Runnable() {
						@Override
						public void run() {
							textInfo.setText("Ожидаем второго игрока...");
						}
					});
				}

				catch (Exception e) {
					if (errorWindow == false) {
						errors("Произошла непредвиденная ошибка: попробуйте еще раз");
						errorWindow = true;
					}
				}

				// Создаем новую игру и ждем ее начала
				try {
					message = client.readMessage();
				}

				catch (Exception e) {
					if (errorWindow == false) {
						errors("Произошла непредвиденная ошибка: попробуйте еще раз");
						errorWindow = true;
					}
				}
				// System.out.println("income message - " +
				// message.getMessageType());
				try {
					if (message.getMessageType().equals(Type.STARTED))
						Display.getDefault().asyncExec(new Runnable() {

							@Override
							public void run() {
								try {
									initializeGame();
								} catch (Exception e) {
									if (errorWindow == false) {
										errors("Произошла непредвиденная ошибка: попробуйте еще раз");
										errorWindow = true;
									}
								}
							}
						});
				} catch (Exception e) {
					if (errorWindow == false) {
						errors("Произошла непредвиденная ошибка: попробуйте еще раз");
						errorWindow = true;
					}
				}
			}
		}).start();
	}

	// выбор сессии для подключения из списка текущих
	public void connectSession() {
		gameID = 2;
		// System.out.println("Second client");
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					client = new Client("localhost", 5876);
				} catch (Exception e) {
					if (errorWindow == false) {
						errors("Произошла непредвиденная ошибка: попробуйте еще раз");
						errorWindow = true;
					}
				}
				
				try {
					client.joinSession(1);
				} catch (Exception e) {
					if (errorWindow == false) {
						errors("Произошла непредвиденная ошибка: попробуйте еще раз");
						errorWindow = true;
					}
				}
				
				try {
					client.sendMessage(new Message(Message.Type.JOIN, ""));
				} catch (Exception e) {
					if (errorWindow == false) {
						errors("Произошла непредвиденная ошибка: попробуйте еще раз");
						errorWindow = true;
					}
				}
				
				try {
					message = client.readMessage();
					// System.out.println("income message - " +
					// message.getMessageType());
				} catch (Exception e) {
					if (errorWindow == false) {
						errors("Произошла непредвиденная ошибка: попробуйте еще раз");
						errorWindow = true;
					}
				}
				
				if (message.getMessageType().equals(Type.STARTED))
					Display.getDefault().asyncExec(new Runnable() {

						@Override
						public void run() {
							try {
								joinGame();
							} catch (Exception e) {
								if (errorWindow == false) {
									errors("Произошла непредвиденная ошибка: попробуйте еще раз");
									errorWindow = true;
								}
							}
						}
					});
			}
		}).start();
	}

	// начинаем новую игру
	public void initializeGame() throws IOException {
		gameStarted = true;
		score = 0;
		drawBlocks();

		createNullTetramino();

		try {
			message = client.readMessage();
			// System.out.println("income message - " +
			// message.getMessageType());
		} catch (Exception e) {
			if (errorWindow == false) {
				errors("Произошла непредвиденная ошибка: попробуйте еще раз");
				errorWindow = true;
			}
		}

		processingClient(message);
		getDisplay().timerExec(0, this);// вызывает метод run
	}

	// присоединяемся к существующей игре
	public void joinGame() throws IOException {
		getShell().setSize(545, 595);
		gameStarted = true;
		score = 0;
		drawBlocks();

		// создаем 3 фигуры для выбора 2-му игроку
		for (int i = 0; i < 3; i++) {
			createTetraminoSelection(i);
			transformTetraminoToBlocks();
		}
		// создаем первую фигуру для игрового поля (рандомно)
		createNullTetramino();

		// запускаем игровой цикл
		getDisplay().timerExec(0, this); // вызывает метод run
	}

	// ф-я окончания игры
	private void gameOver() {
		getDisplay().timerExec(-1, this); // отменяем выполнение
		try {
			client.closeSession();
		} catch (Exception e) {
			if (errorWindow == false) {
				errors("Произошла непредвиденная ошибка: попробуйте еще раз");
				errorWindow = true;
			}
		}
		gameStarted = false;
		choose = false;
		errorWindow = false;
		speed = 0;
		message = null;
	}

	public void drawBlocks() {
		blocks = new Block[X_SIZE][Y_SIZE];// создаем массив для поля

		// создаем само поле из пустых блоков
		for (int i = 0; i < X_SIZE; i++) {
			for (int j = 0; j < Y_SIZE - 1; j++) {
				blocks[i][j] = new Block(getDisplay().getSystemColor(SWT.COLOR_WHITE), false);
			}
		}
		// создаем горизонтальные границы поля
		for (int i = 0; i < X_SIZE; i++) {
			blocks[i][Y_SIZE - 1] = new Block(getDisplay().getSystemColor(gridColor), true);
		}

		for (int i = 17; i < X_SIZE; i++) {
			blocks[i][7] = new Block(getDisplay().getSystemColor(gridColor), true);
			blocks[i][15] = new Block(getDisplay().getSystemColor(gridColor), true);
		}

		// создаем вертикальные границы поля
		for (int i = 0; i < Y_SIZE; i++) {
			blocks[0][i] = new Block(getDisplay().getSystemColor(gridColor), true);
			blocks[14][i] = new Block(getDisplay().getSystemColor(gridColor), true);
			blocks[15][i] = new Block(getDisplay().getSystemColor(gridColor), true);
			blocks[16][i] = new Block(getDisplay().getSystemColor(gridColor), true);
		}
	}

	// ф-я управления видимостью сетки
	public void isGridEnabled(boolean grid) {
		if (grid)
			gridColor = SWT.COLOR_GRAY;
		else
			gridColor = SWT.COLOR_WHITE;
	}

	// ф-я создания "нулевой" (первой, рандомной) фигуры
	private void createNullTetramino() throws IOException {
		tetramino = new Tetramino(this, Shape.Z, 7, 0);
		// buffer = tetramino.shape;
		// Message message = new Message(Type.FORMNUMBER, "");
		// message.setAdditionalData(buffer);
		// client.sendMessage(message);

	}

	// ф-я создания новых фигур сверху посередине игрового поля в зависимости от
	// shape'а (сообщения пришедшего от 2-го игрока)
	private void createTetramino(Shape shape) {
		tetramino = new Tetramino(this, shape, 7, 0);
	}

	// ф-я создания новых РАЗНЫХ фигур на выбор для 2-го игрока (и записывания
	// их в массив)
	private void createTetraminoSelection(int i) {
		if (i == 0) {
			tetramino = new Tetramino(this, 19, i * 8 + 2);
			if (tetramino.shape == Shape.I) {
				Shape shape = tetramino.shape;
				tetramino = new Tetramino(this, shape, 20, i * 8 + 2);
			}
			figuresChoose[i] = tetramino.shape;
		}
		if (i == 1) {
			tetramino = new Tetramino(this, 19, i * 8 + 2);
			while (tetramino.shape == figuresChoose[0]) {
				tetramino = new Tetramino(this, 19, i * 8 + 2);
			}
			if (tetramino.shape == Shape.I) {
				Shape shape = tetramino.shape;
				tetramino = new Tetramino(this, shape, 20, i * 8 + 2);
			}
			figuresChoose[i] = tetramino.shape;
		}
		if (i == 2) {
			tetramino = new Tetramino(this, 19, i * 8 + 2);
			while (tetramino.shape == figuresChoose[0] || tetramino.shape == figuresChoose[1]) {
				tetramino = new Tetramino(this, 19, i * 8 + 2);
			}
			if (tetramino.shape == Shape.I) {
				Shape shape = tetramino.shape;
				tetramino = new Tetramino(this, shape, 20, i * 8 + 2);
			}
			figuresChoose[i] = tetramino.shape;
		}
	}

	// очищение полей, для выбора фигур
	private void clearTetraminoSelection() {
		for (int i = 17; i < X_SIZE - 1; i++) {
			for (int j = 1; j < Y_SIZE - 1; j++) {
				if (j != 7 && j != 15 && blocks[i][j].getFilled()) {
					blocks[i][j] = new Block(getDisplay().getSystemColor(SWT.COLOR_WHITE), false);
				}
			}
		}
	}

	// ф-я, преобразующая активную фигуру в блоки поля
	private void transformTetraminoToBlocks() {
		for (int x = 0; x < 4; x++) {
			for (int y = 0; y < 4; y++) {
				if (tetramino.field[x][y] == true) {
					blocks[tetramino.x + x][tetramino.y + y].setColor(tetramino.color);// блок
																						// становится
																						// цвета
																						// фигуры
					blocks[tetramino.x + x][tetramino.y + y].setFilled(true);// теперь
																				// блок
																				// не
																				// пустой
				}
			}
		}
	}

	// проверка, достигла ли фигура заполненных блоков (границ поля или "старых"
	// фигур)
	private boolean isTouching(int x, int y) {
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < 4; j++) {
				if (tetramino.field[i][j] == true && tetramino.x + i + x >= 0
						&& blocks[tetramino.x + i + x][tetramino.y + j + y].getFilled() == true) {
					return true;
				}
			}
		}
		return false;
	}

	private boolean stepDown() {// фигура двигается вниз, пока не достигнет дна
		// (или других "старых"
		// фигур)
		if (!isTouching(0, 1)) {
			tetramino.y++;
			return true;
		} else { // если фигура достигла дна, то:
			if (tetramino.y <= 3) {// game over, если осталось меньше 3-х
				// свободных полос
				gameOver();
				return false;
			}
			if (gameID == 2) {
				if (choose == false) { // если 2-й игрок не сделал выбор, то
										// фигура добавляется рандомно
					int random = (int) Math.floor(Math.random() * 3);
					buffer = figuresChoose[random];
					message = new Message(Message.Type.FORMNUMBER, "");
					message.setAdditionalData(buffer);
					try {
						client.sendMessage(message);
					} catch (Exception e) {
						if (errorWindow == false) {
							errors("Произошла непредвиденная ошибка: попробуйте еще раз");
							errorWindow = true;
						}
					}
				}
			}
			transformTetraminoToBlocks();
			choose = false;
			clearTetraminoSelection();
			for (int i = 0; i < 3; i++) {
				createTetraminoSelection(i);
				transformTetraminoToBlocks();
			}
		}
		if (gameID == 1) {
			int counter = 0;
			while (buffer == null) {
				try {
					counter++;
					if (counter > 3) {
						errors("Игрок 2 отключился. Приложение будет завершено.");
						gameOver();
						getDisplay().dispose();
					}
					//if (client.hasMessage()) {
						message = client.readMessage();
						processingClient(message);
					//}
				} catch (Exception e) {
					if (errorWindow == false) {
						errors("Произошла непредвиденная ошибка: попробуйте еще раз");
						errorWindow = true;
					}
				}
			}
		}
		transformTetraminoToBlocks();
		createTetramino(buffer);
		buffer = null;
		return false;
	}

	private void stepLeft() {// двигайся влево, пока не достиг стены (или других
								// фигур)
		if (!isTouching(-1, 0)) {
			tetramino.x--;
		}
	}

	private void stepRight() {// аналогично вправо
		if (!isTouching(1, 0)) {
			tetramino.x++;
		}
	}

	// очищение заполненной линии и смещение остальных на один блок вниз
	private void clearFullLine(int current) {
		for (int i = current; i > 0; i--) {
			for (int j = 0; j < X_SIZE - 10; j++) {
				blocks[j][i].setColor(blocks[j][i - 1].getColor());// смещаем
																	// цвет на
																	// блок вниз
				blocks[j][i].setFilled(blocks[j][i - 1].getFilled());// аналогично
																		// с
																		// заполненностью
			}
		}
	}

	// проверка линии (заполнилась ли?)
	private void checkLine() {
		boolean gap = false;
		for (int i = 0; i < Y_SIZE - 1; i++) {
			gap = false;// пробел
			for (int j = 1; j < X_SIZE - 10; j++) {
				if (!blocks[j][i].getFilled()) {
					gap = true;// если нашли пробел в линии
				}
			}
			if (!gap) { // если пробелов нет, очистить текущую линию и увеличить
						// счет на 1
				clearFullLine(i);
				scoreUp();

			}
		}
	}

	// ф-я увеличения кол-ва очков
	private void scoreUp() {
		score += 10;
		if (score % 100 == 0) {
			level++;// увеличивать уровень каждые 100 очков
			speedUp();
		}
	}

	// ф-я увеличения скорости игры
	private void speedUp() {
		speed += 30;
		if (speed > 499)
			speed = 499;
	}

	// обработка сообщений
	private void processingClient(Message answer) {
		if (answer.getMessageType().equals(Type.KEYNUMBER)) {
			// System.out.println("income message - " + answer.getMessageType()
			// + " + " + answer.getMessage());
			keyP(answer.getMessage());
		}
		if (answer.getMessageType().equals(Type.SUCCESS)) {
			// System.out.println("income message - " +
			// answer.getMessageType());
		} else if (answer.getMessageType().equals(Type.FORMNUMBER)) {
			// System.out.println("income message lalala - " +
			// answer.getMessageType() + " + " + answer.getMessage());
			buffer = (Shape) answer.getAdditionalData();
			choose = true;
		}

	}

	public void run() {
		if (gameStarted) {
			iteration();
		}
	}

	public void iteration() {
		if (gameID == 1) {
			try {
				if (client.hasMessage()) {
					try {
						message = client.readMessage();
					} catch (Exception e) {
						if (errorWindow == false) {
							errors("Произошла непредвиденная ошибка: попробуйте еще раз");
							gameOver();
							errorWindow = true;
						}
					}
					processingClient(message);
				}
			}

			catch (Exception e) {
				if (errorWindow == false) {
					errors("Произошла непредвиденная ошибка: попробуйте еще раз");
					gameOver();
					errorWindow = true;
				}
			}
			stepDown();// движение вниз
			redraw();// перерисовка фигуры
			checkLine(); // проверка заполненных линиий
			getDisplay().timerExec(500 - speed, this);
		} else if (gameID == 2) {
			try {
				if (client.hasMessage()) {
					try {
						processingClient(client.readMessage());

					} catch (Exception e) {
						if (errorWindow == false) {
							errors("Произошла непредвиденная ошибка: попробуйте еще раз");
							gameOver();
							errorWindow = true;
						}
					}
				}
			} catch (Exception e) {
				if (errorWindow == false) {
					errors("Произошла непредвиденная ошибка: попробуйте еще раз");
					gameOver();
					errorWindow = true;
				}
			}
			stepDown();// движение вниз
			redraw();// перерисовка фигуры
			checkLine(); // проверка заполненных линиий
			getDisplay().timerExec(500 - speed, this);
		}
	}

	// рисование фигур
	private void drawTetramino(GC gc, Tetramino tetramino) {
		for (int x = 0; x < 4; x++) {
			for (int y = 0; y < 4; y++) {
				if (tetramino.field[x][y] == true) {
					gc.setBackground(tetramino.color);// цвет фигуры
					gc.fillRectangle(// заливает прямоугольники (блоки)
										// указанным в пред.строке цветом
							(tetramino.x + x) * 21 + 3, (tetramino.y + y) * 21 + 31, // координаты
																						// по
																						// иксу
																						// и
																						// по
																						// игреку
							19, 19); // ширина и высота
				}
			}
		}
	}

	public void keyP(String str) {

		if (str.equals("vverh")) { // если вверх, то вращаем
									// фигуру
			tetramino.rotate();
			while (isTouching(0, 0)) {// чтобы фигура не застревала в правой
										// границе поля
				tetramino.x--;
			}
			redraw();
		} else if (str.equals("vniz")) {
			stepDown();
			redraw();
		} else if (str.equals("vlevo")) {
			stepLeft();
			redraw();
		} else if (str.equals("vpravo")) {
			stepRight();
			redraw();
		}
	}

	// события, связанные с нажатием клавиш (зависят от id игрока!)
	public void keyPressed(KeyEvent key) {
		if (gameID == 1) { // действия 1-го игрока
			message = new Message(Message.Type.KEYNUMBER, "");

			if (key.keyCode == SWT.ARROW_UP) { // если вверх, то вращаем
												// фигуру
				tetramino.rotate();
				while (isTouching(0, 0)) {// чтобы фигура не застревала в правой
											// границе поля
					tetramino.x--;
				}
				redraw();
				message.setMessage("vverh");
			} else if (key.keyCode == SWT.ARROW_DOWN) {
				stepDown();
				redraw();
				message.setMessage("vniz");
			} else if (key.keyCode == SWT.ARROW_LEFT) {
				stepLeft();
				redraw();
				message.setMessage("vlevo");
			} else if (key.keyCode == SWT.ARROW_RIGHT) {
				stepRight();
				redraw();
				message.setMessage("vpravo");
			}
			try {
				client.sendMessage(message);
			} catch (Exception e) {
				if (errorWindow == false) {
					errors("Произошла непредвиденная ошибка: попробуйте еще раз");
					gameOver();
					errorWindow = true;
				}
			}
		}
		if (gameID == 2) { // действия 2-го игрока
			message = new Message(Message.Type.FORMNUMBER, "");
			if (key.keyCode == SWT.ARROW_UP) { // если вверх, то выбираем 1-ю
												// фигуру
				if (choose == false) {
					buffer = figuresChoose[0];
					choose = true; // выбор сделан!

				}

			} else if (key.keyCode == SWT.ARROW_DOWN) { // если вниз, то
														// выбираем
														// 3-ю
														// фигуру
				if (choose == false) {
					buffer = figuresChoose[2];
					choose = true;
				}

			} else if (key.keyCode == SWT.ARROW_LEFT || key.keyCode == SWT.ARROW_RIGHT) { // если
																							// вправо/влево,
																							// то
																							// выбираем
																							// 2-ю
																							// фигуру
				if (choose == false) {
					buffer = figuresChoose[1];
					choose = true;

				}
			}
			message.setAdditionalData(buffer);
			try {
				client.sendMessage(message);
			} catch (Exception e) {
				if (errorWindow == false) {
					errors("Произошла непредвиденная ошибка: попробуйте еще раз");
					gameOver();
					errorWindow = true;
				}
			}
		}

	}

	public void keyReleased(KeyEvent e) {// действия, связанные с отпусканием
											// клавиш
		//
	}

	// освобождаем ресурсы
	public void widgetDisposed(DisposeEvent e) {
		getDisplay().timerExec(-1, this);
		gc.dispose();
		backimage.dispose();
	}

	public void paintControl(PaintEvent e) {
		if (gameStarted) {
			// заполнение фона, если идет игра
			gc.setBackground(getDisplay().getSystemColor(gridColor));
			gc.fillRectangle(getClientArea());// заливаем

			// рисование блоков
			for (int i = 0; i < X_SIZE; i++) {
				for (int j = 0; j < Y_SIZE; j++) {
					gc.setBackground(blocks[i][j].getColor());
					gc.fillRectangle(i * 21 + 3, j * 21 + 31, 19, 19);
				}
			}

			textInfo.setText("Уровень: " + level + " Счёт: " + score + "");// ин-ция
																			// о
																			// текущем
																			// уровне
																			// и
																			// счете
			// фигуры
			drawTetramino(gc, tetramino);
		} else {// если игра окончена
			gc.setBackground(getDisplay().getSystemColor(SWT.COLOR_DARK_CYAN));
			gc.fillRectangle(getClientArea());
			textInfo.setText("Итоговый счет: " + score);
		}

		if (e != null)
			e.gc.drawImage(backimage, 0, 0);// отрисовываем
	}

}